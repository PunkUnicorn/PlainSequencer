using Autofac;
using FluentAssertions;
using Moq;
using Newtonsoft.Json;
using PactTests;
using PactTests_Shared;
using PlainSequencer.Logging;
using PlainSequencer.Options;
using PlainSequencer.Script;
using PlainSequencer.SequenceItemActions;
using PlainSequencer.SequenceItemSupport;
using System;
using System.Collections.Generic;
using System.Dynamic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Threading;
using System.Threading.Tasks;
using Xunit;
using Xunit.Abstractions;

namespace PactTests_OpenTests
{
    public class HttpSequencer_ISequenceItemAction
    {
        private readonly PortAllocationFixture mrPorty = new PortAllocationFixture(6000);
        private readonly ITestOutputHelper mrOutput;

        public Func<int> GetAvailablePort => mrPorty.GetAvailablePort;

        private ConsumeHttpSequencerPact ConsumeTestYamlPact { get; }
        private int Port { get; }

        private string ExecutableFilename = @".\DosAndLinuxBashScript.cmd";
        private string ExecutableExpectedResult = "EXPECTED RESULT";
        private Mock<ISequenceItemAction.AddToFailHoleAsync> mockErrorHole = new Mock<ISequenceItemAction.AddToFailHoleAsync>(MockBehavior.Strict);

        private void AssertErrorHoleEmpty() => mockErrorHole.Verify(p => p(It.IsAny<SequenceItemAbstract>(), It.IsAny<Dictionary<string, object>>(), It.IsAny<CancellationToken>()), Times.Never);

        public HttpSequencer_ISequenceItemAction(ITestOutputHelper output)
        {
            Port = GetAvailablePort();
            var consumerName = $"{nameof(HttpSequencer_ISequenceItemAction)}Consumer";
            ConsumeTestYamlPact = new ConsumeHttpSequencerPact(consumerName, Port);
            ConsumeTestYamlPact.MockProviderService.ClearInteractions();
            mrOutput = output;

            mockErrorHole.Setup(p => p(It.IsAny<SequenceItemAbstract>(), It.IsAny<Dictionary<string, object>>(), It.IsAny<CancellationToken>()))
                .Returns(Task.CompletedTask)
                .Verifiable();
        }

        [Fact]
        public void SequenceItemActionRun_ExpectSuccess()
        {
            /* 𝓐𝓻𝓻𝓪𝓷𝓰𝓮... */
            var testSequenceItem = new SequenceItem
            {
                name = "test-cmd-script",
                run = new Run { exec = ExecutableFilename }
            };

            using var container = AutofacTestSession.ConfigureTestSession(new CommandLineOptions());
            using var scope = container?.BeginLifetimeScope();
            scope.Should().NotBeNull("Test malfunction: can't create DI scope");

            var factory = scope.Resolve<ISequenceItemActionFactory>();
            var testParams = new SequenceItemCreateParams { Model = null, NextSequenceItems = new SequenceItem[] { }, SequenceItem = testSequenceItem };
            var factoryResult = factory.ResolveSequenceItemAction(testSequenceItem, testParams);
            var testSequenceItemAction = (ISequenceItemAction)factoryResult;

            /* 𝓐𝓬𝓽 */
            var resultModel = (string)testSequenceItemAction.ActionAsync(mockErrorHole.Object, CancellationToken.None).Result;


            /* 𝓐𝓼𝓼𝓮𝓻𝓽 */
            var result = (ISequenceItemResult)testSequenceItemAction;

            result.IsFail.Should().BeFalse();

            result.Exception.Should().BeNull();

            resultModel.Should().EndWith(ExecutableExpectedResult);

            AssertErrorHoleEmpty();

            var sequenceNotation = container.Resolve<ILogSequence>().GetSequenceDiagramNotation(MethodBase.GetCurrentMethod().Name);
            mrOutput.WriteLine(sequenceNotation);
        }

        [Theory]
        [InlineData(true, "")]
        [InlineData(false, null)]
        public void SequenceItemActionRun_ExpectFail(bool continueOnError, string expectedOutput)
        {
            /* 𝓐𝓻𝓻𝓪𝓷𝓰𝓮... */
            var testSequenceItem = new SequenceItem
            {
                name = "some-run-command",
                is_continue_on_failure = continueOnError,
                run = new Run { exec = "this is an invalid command" }
            };

            using var container = AutofacTestSession.ConfigureTestSession(new CommandLineOptions());
            using var scope = container?.BeginLifetimeScope();
            scope.Should().NotBeNull("Test malfunction: can't create DI scope");

            var factory = scope.Resolve<ISequenceItemActionFactory>();
            var testParams = new SequenceItemCreateParams { Model = null, NextSequenceItems = new SequenceItem[] { }, SequenceItem = testSequenceItem };
            var factoryResult = factory.ResolveSequenceItemAction(testSequenceItem, testParams);
            var testSequenceItemAction = (ISequenceItemAction)factoryResult;


            /* 𝓐𝓬𝓽 */
            var resultModel = testSequenceItemAction.ActionAsync(mockErrorHole.Object, CancellationToken.None).Result;


            /* 𝓐𝓼𝓼𝓮𝓻𝓽 */
            var result = (ISequenceItemResult)testSequenceItemAction;

            result.IsFail.Should().BeTrue();

            result.Exception.Should().NotBeNull();

            resultModel.Should().BeNull();

            mockErrorHole.Verify();

            result.ActionResult.Should().Be(expectedOutput);


            /* 𝓢𝓮𝓺𝓾𝓮𝓷𝓬𝓮 𝓓𝓲𝓪𝓰𝓻𝓪𝓶 */

            var sequenceNotation = container.Resolve<ILogSequence>().GetSequenceDiagramNotation(MethodBase.GetCurrentMethod().Name);
            mrOutput.WriteLine(sequenceNotation);
        }

        [Fact]
        public void SequenceItemActionRun_ScribanSubstitute()
        {
            /* 𝓐𝓻𝓻𝓪𝓷𝓰𝓮... */
            var testSequenceItem = new SequenceItem
            {
                name = "test-cmd-script",
                run = new Run { exec = "{{model.param1}}" }
            };

            var testModel = new { param1 = ExecutableFilename };

            using var container = AutofacTestSession.ConfigureTestSession(new CommandLineOptions());
            using var scope = container?.BeginLifetimeScope();
            scope.Should().NotBeNull("Test malfunction: can't create DI scope");

            var factory = scope.Resolve<ISequenceItemActionFactory>();
            var testParams = new SequenceItemCreateParams { Model = testModel, NextSequenceItems = new SequenceItem[] { }, SequenceItem = testSequenceItem };
            var factoryResult = factory.ResolveSequenceItemAction(testSequenceItem, testParams);
            var testSequenceItemAction = (ISequenceItemAction)factoryResult;


            /* 𝓐𝓬𝓽 */
            var resultModel = (string)testSequenceItemAction.ActionAsync(mockErrorHole.Object, CancellationToken.None).Result;
            

            /* 𝓐𝓼𝓼𝓮𝓻𝓽 */
            var result = (ISequenceItemResult)testSequenceItemAction;

            result.IsFail.Should().BeFalse();

            result.Exception.Should().BeNull();

            resultModel.Should().EndWith(ExecutableExpectedResult);

            AssertErrorHoleEmpty();

            var sequenceNotation = container.Resolve<ILogSequence>().GetSequenceDiagramNotation(MethodBase.GetCurrentMethod().Name);
            mrOutput.WriteLine(sequenceNotation);
        }

        [Fact]
        public void SequenceItemActionCheck_ExpectSuccess()
        {
            /* 𝓐𝓻𝓻𝓪𝓷𝓰𝓮... */
            var testSequenceItem = new SequenceItem
            {
                name = "check-item",
                check = new Check { pass_template = "true" }
            };

            var testModel = new { SomeData = "this is some data" };

            using var container = AutofacTestSession.ConfigureTestSession(new CommandLineOptions());
            using var scope = container?.BeginLifetimeScope();

            scope.Should().NotBeNull("Test malfunction: can't create DI scope");

            var factory = scope.Resolve<ISequenceItemActionFactory>();
            var testParams = new SequenceItemCreateParams { Model = testModel, NextSequenceItems = new SequenceItem[] { }, SequenceItem = testSequenceItem };
            var factoryResult = factory.ResolveSequenceItemAction(testSequenceItem, testParams);
            var testSequenceItemAction = (ISequenceItemAction)factoryResult;


            /* 𝓐𝓬𝓽 */
            var actual = testSequenceItemAction.ActionAsync(mockErrorHole.Object, CancellationToken.None).Result;


            /* 𝓐𝓼𝓼𝓮𝓻𝓽 */
            var resultModel = (ISequenceItemResult)testSequenceItemAction;

            resultModel.IsFail.Should().BeFalse();

            resultModel.Exception.Should().BeNull();

            JsonConvert.SerializeObject(actual).Should().Be(JsonConvert.SerializeObject(testModel));

            AssertErrorHoleEmpty();

            var sequenceNotation = container.Resolve<ILogSequence>().GetSequenceDiagramNotation(MethodBase.GetCurrentMethod().Name);
            mrOutput.WriteLine(sequenceNotation);
        }

        [Theory]
        [InlineData(true, "{\"SomeData\":\"this is some data\"}")]
        [InlineData(false, null)]
        public void SequenceItemActionCheck_ExpectFail(bool continueOnError, string expectedOutput)
        {
            /* 𝓐𝓻𝓻𝓪𝓷𝓰𝓮... */
            const string commandName = "check-item-expect-fail";

            var testSequenceItem = new SequenceItem
            {
                name = commandName,
                is_continue_on_failure = continueOnError,
                check = new Check { pass_template = "false" }
            };

            var testModel = new { SomeData = "this is some data" };

            using var container = AutofacTestSession.ConfigureTestSession(new CommandLineOptions());
            using var scope = container?.BeginLifetimeScope();
            scope.Should().NotBeNull("Test malfunction: can't create DI scope");

            var factory = scope.Resolve<ISequenceItemActionFactory>();
            var testParams = new SequenceItemCreateParams { Model = testModel, NextSequenceItems = new SequenceItem[] { }, SequenceItem = testSequenceItem };
            var factoryResult = factory.ResolveSequenceItemAction(testSequenceItem, testParams);
            var testSequenceItemAction = (ISequenceItemAction)factoryResult;


            /* 𝓐𝓬𝓽 */
            var resultModel = testSequenceItemAction.ActionAsync(mockErrorHole.Object, CancellationToken.None).Result;


            /* 𝓐𝓼𝓼𝓮𝓻𝓽 */
            var result = (ISequenceItemResult)testSequenceItemAction;

            result.IsFail.Should().BeTrue();

            result.Exception.Should().NotBeNull();

            result.Exception.Message.Should().Contain(commandName);

            if (continueOnError)
            {
                result.ActionResult.Should().NotBeNull();
                JsonConvert.SerializeObject(result.ActionResult).Should().Be(expectedOutput);
            }
            else
                result.ActionResult.Should().BeNull();

            mockErrorHole.Verify();

            /* 𝓢𝓮𝓺𝓾𝓮𝓷𝓬𝓮 𝓓𝓲𝓪𝓰𝓻𝓪𝓶 */

            var sequenceNotation = container.Resolve<ILogSequence>().GetSequenceDiagramNotation(MethodBase.GetCurrentMethod().Name);
            mrOutput.WriteLine(sequenceNotation);
        }

        [Fact]
        public void SequenceItemActionCheck_ScribanSubstitute_CheckPasses()
        {
            /* 𝓐𝓻𝓻𝓪𝓷𝓰𝓮... */
            var testSequenceItem = new SequenceItem
            {
                name = "test-check-item-sriban-expect-pass",
                check = new Check { pass_template = "{{if model.someData == 'the correct data'}}true{{else}}false{{end}}", fail_info_template = "Check failed with value: {{model.someData}}" }
            };

            var testModel = new { someData = "the correct data" };

            using var container = AutofacTestSession.ConfigureTestSession(new CommandLineOptions());
            using var scope = container?.BeginLifetimeScope();

            scope.Should().NotBeNull("Test malfunction: can't create DI scope");

            var factory = scope.Resolve<ISequenceItemActionFactory>();
            var testParams = new SequenceItemCreateParams { Model = testModel, NextSequenceItems = new SequenceItem[] { }, SequenceItem = testSequenceItem };
            var factoryResult = factory.ResolveSequenceItemAction(testSequenceItem, testParams);
            var testSequenceItemAction = (ISequenceItemAction)factoryResult;


            /* 𝓐𝓬𝓽 */
            var resultModel = testSequenceItemAction.ActionAsync(mockErrorHole.Object, CancellationToken.None).Result;


            /* 𝓐𝓼𝓼𝓮𝓻𝓽 */
            var result = (ISequenceItemResult)testSequenceItemAction;

            result.IsFail.Should().BeFalse();

            result.Exception.Should().BeNull();

            JsonConvert.SerializeObject(resultModel).Should().Be(JsonConvert.SerializeObject(testModel));

            AssertErrorHoleEmpty();

            var sequenceNotation = container.Resolve<ILogSequence>().GetSequenceDiagramNotation(MethodBase.GetCurrentMethod().Name);
            mrOutput.WriteLine(sequenceNotation);
        }

        [Theory]
        [InlineData(true, "{\"SomeData\":\"this is NOT the correct data\"}")]
        [InlineData(false, null)]
        public void SequenceItemActionCheck_ScribanSubstitute_CheckFails(bool continueOnError, string expectedOutput)
        {
            /* 𝓐𝓻𝓻𝓪𝓷𝓰𝓮... */
            const string commandName = "some-check-sriban-expect-fail";
            var testSequenceItem = new SequenceItem
            {
                name = commandName,
                is_continue_on_failure = continueOnError,
                check = new Check { pass_template = "{{if model.someData == 'the correct data'}}true{{else}}false{{end}}", fail_info_template = "Check failed with value: {{model.someData}}" }
            };

            var testModel = new { someData = "this is NOT the correct data" };

            using var container = AutofacTestSession.ConfigureTestSession(new CommandLineOptions());
            using var scope = container?.BeginLifetimeScope();

            scope.Should().NotBeNull("Test malfunction: can't create DI scope");

            var factory = scope.Resolve<ISequenceItemActionFactory>();
            var testParams = new SequenceItemCreateParams { Model = testModel, NextSequenceItems = new SequenceItem[] { }, SequenceItem = testSequenceItem };
            var factoryResult = factory.ResolveSequenceItemAction(testSequenceItem, testParams);
            var testSequenceItemAction = (ISequenceItemAction)factoryResult;


            /* 𝓐𝓬𝓽 */
            var resultModel = testSequenceItemAction.ActionAsync(mockErrorHole.Object, CancellationToken.None).Result;


            /* 𝓐𝓼𝓼𝓮𝓻𝓽 */
            var result = (ISequenceItemResult)testSequenceItemAction;

            result.IsFail.Should().BeTrue();

            result.Exception.Should().NotBeNull();

            result.Exception.Message.Should().Contain(commandName);

            JsonConvert.SerializeObject(resultModel).Should().Be(JsonConvert.SerializeObject(testModel));

            if (continueOnError)
            {
                result.ActionResult.Should().NotBeNull();
                JsonConvert.SerializeObject(result.ActionResult).Should().BeEquivalentTo(expectedOutput);
            }
            else
                result.ActionResult.Should().BeNull();

            mockErrorHole.Verify();

            /* 𝓢𝓮𝓺𝓾𝓮𝓷𝓬𝓮 𝓓𝓲𝓪𝓰𝓻𝓪𝓶 */

            var sequenceNotation = container.Resolve<ILogSequence>().GetSequenceDiagramNotation(MethodBase.GetCurrentMethod().Name);
            mrOutput.WriteLine(sequenceNotation);
        }

        [Fact]
        public void SequenceItemActionCheck_ScribanSubstitute_InvalidScriban()
        {
            /* 𝓐𝓻𝓻𝓪𝓷𝓰𝓮... */
            var testSequenceItem = new SequenceItem
            {
                name = "some-check-scriban-expect-invalid-template",
                check = new Check { pass_template = "{{this is not valid scriban!}}true{{else}}false{{end}}" }
            };

            var testModel = new { someData = "some data" };

            using var container = AutofacTestSession.ConfigureTestSession(new CommandLineOptions());
            using var scope = container?.BeginLifetimeScope();

            scope.Should().NotBeNull("Test malfunction: can't create DI scope");

            var factory = scope.Resolve<ISequenceItemActionFactory>();
            var testParams = new SequenceItemCreateParams { Model = testModel, NextSequenceItems = new SequenceItem[] { }, SequenceItem = testSequenceItem };
            var factoryResult = factory.ResolveSequenceItemAction(testSequenceItem, testParams);
            var testSequenceItemAction = (ISequenceItemAction)factoryResult;

            /* 𝓐𝓬𝓽 */
            var resultModel = testSequenceItemAction.ActionAsync(mockErrorHole.Object, CancellationToken.None).Result;


            /* 𝓐𝓼𝓼𝓮𝓻𝓽 */
            var result = (ISequenceItemResult)testSequenceItemAction;

            result.IsFail.Should().BeTrue();

            result.Exception.Should().NotBeNull();

            resultModel.Should().BeNull();

            mockErrorHole.Verify();

            /* 𝓢𝓮𝓺𝓾𝓮𝓷𝓬𝓮 𝓓𝓲𝓪𝓰𝓻𝓪𝓶 */

            var sequenceNotation = container.Resolve<ILogSequence>().GetSequenceDiagramNotation(MethodBase.GetCurrentMethod().Name);
            mrOutput.WriteLine(sequenceNotation);
        }

        [Fact]
        public void SequenceItemActionLoad_Csv_BasicallyWorks()
        {
            /* 𝓐𝓻𝓻𝓪𝓷𝓰𝓮... */
            using var t = new TempFile();
            File.WriteAllText(t.Filename, "headerA,headerB,headerC\nrow1a,row1b,row1c\nrow2a,row2b,row2c");

            var testSequenceItem = new SequenceItem
            {
                name = "csv-load",
                load = new Load { csv = t.Filename }
            };

            using var container = AutofacTestSession.ConfigureTestSession(new CommandLineOptions());
            using var scope = container?.BeginLifetimeScope();

            scope.Should().NotBeNull("Test malfunction: can't create DI scope");

            var factory = scope.Resolve<ISequenceItemActionFactory>();
            var testParams = new SequenceItemCreateParams { Model = "expect this model is passed through", NextSequenceItems = new SequenceItem[] { }, SequenceItem = testSequenceItem };
            var factoryResult = factory.ResolveSequenceItemAction(testSequenceItem, testParams);
            var testSequenceItemAction = (ISequenceItemAction)factoryResult;

            /* 𝓐𝓬𝓽 */
            var resultModel = testSequenceItemAction.ActionAsync(mockErrorHole.Object, CancellationToken.None).Result;

            /* 𝓐𝓼𝓼𝓮𝓻𝓽 */
            var result = (ISequenceItemResult)testSequenceItemAction;

            result.IsFail.Should().BeFalse();
            result.Exception.Should().BeNull();
            result.ActionResult.Should().Be(testParams.Model);

            result.NewVariables.Should().ContainSingle();
            result.NewVariables.Single().Value.Should().BeAssignableTo<List<ExpandoObject>>();
            var actualData = result.NewVariables.Single().Value as List<ExpandoObject>;

            var firstRow = (IDictionary<string, object>)actualData.First();
            firstRow.Should().HaveCount(3);
            firstRow.Should().ContainInOrder(new KeyValuePair<string, object>[] 
            { 
                new ("headerA", "row1a"),
                new ("headerB", "row1b"),
                new ("headerC", "row1c"),
            });

            var secondRow = (IDictionary<string, object>)actualData.Skip(1).First();
            secondRow.Should().HaveCount(3);
            secondRow.Should().ContainInOrder(new KeyValuePair<string, object>[]
            {
                new ("headerA", "row2a"),
                new ("headerB", "row2b"),
                new ("headerC", "row2c"),
            });

            var firstRowDynamic = firstRow as dynamic;
            ((string)firstRowDynamic.headerA).Should().Be("row1a");

            AssertErrorHoleEmpty();

            /* 𝓢𝓮𝓺𝓾𝓮𝓷𝓬𝓮 𝓓𝓲𝓪𝓰𝓻𝓪𝓶 */

            var sequenceNotation = container.Resolve<ILogSequence>().GetSequenceDiagramNotation(MethodBase.GetCurrentMethod().Name);
            mrOutput.WriteLine(sequenceNotation);
        }

        [Theory]
        [InlineData(true, "")]
        [InlineData(false, null)]
        public void SequenceItemActionLoad_Csv_FailsOK(bool outputOnError, string expectedResult)
        {
            /* 𝓐𝓻𝓻𝓪𝓷𝓰𝓮... */
            using var t = new TempFile();
            File.WriteAllText(t.Filename, "headerA,headerA,headerA\nrow1a,row1b,row1c");

            var testSequenceItem = new SequenceItem
            {
                name = "csv-load",
                is_continue_on_failure = outputOnError,
                load = new Load { csv = t.Filename }
            };

            using var container = AutofacTestSession.ConfigureTestSession(new CommandLineOptions());
            using var scope = container?.BeginLifetimeScope();

            scope.Should().NotBeNull("Test malfunction: can't create DI scope");

            var factory = scope.Resolve<ISequenceItemActionFactory>();
            var testParams = new SequenceItemCreateParams { NextSequenceItems = new SequenceItem[] { }, SequenceItem = testSequenceItem };
            var factoryResult = factory.ResolveSequenceItemAction(testSequenceItem, testParams);
            var testSequenceItemAction = (ISequenceItemAction)factoryResult;

            /* 𝓐𝓬𝓽 */
            var resultModel = testSequenceItemAction.ActionAsync(mockErrorHole.Object, CancellationToken.None).Result;

            /* 𝓐𝓼𝓼𝓮𝓻𝓽 */
            var result = (ISequenceItemResult)testSequenceItemAction;
            result.IsFail.Should().BeTrue();
            result.Exception.Should().NotBeNull();
            result.ActionResult.Should().Be(expectedResult);
            mockErrorHole.Verify();

            /* 𝓢𝓮𝓺𝓾𝓮𝓷𝓬𝓮 𝓓𝓲𝓪𝓰𝓻𝓪𝓶 */
            var sequenceNotation = container.Resolve<ILogSequence>().GetSequenceDiagramNotation(MethodBase.GetCurrentMethod().Name);
            mrOutput.WriteLine(sequenceNotation);
        }

        [Fact]
        public void SequenceItemActionLoad_Json_BasicallyWorks()
        {
            /* 𝓐𝓻𝓻𝓪𝓷𝓰𝓮... */
            using var t = new TempFile();
            File.WriteAllText(t.Filename, "{'prop1':'prop1Data','array1':['array1a','array2a'],'complexObj1':{'complexObjProp1':'complexObjProp1Data'}}".Replace('\'', '"'));

            var testSequenceItem = new SequenceItem
            {
                name = "json-load",
                load = new Load { json = t.Filename }
            };

            using var container = AutofacTestSession.ConfigureTestSession(new CommandLineOptions());
            using var scope = container?.BeginLifetimeScope();

            scope.Should().NotBeNull("Test malfunction: can't create DI scope");

            var factory = scope.Resolve<ISequenceItemActionFactory>();
            var testParams = new SequenceItemCreateParams { NextSequenceItems = new SequenceItem[] { }, SequenceItem = testSequenceItem };
            var factoryResult = factory.ResolveSequenceItemAction(testSequenceItem, testParams);
            var testSequenceItemAction = (ISequenceItemAction)factoryResult;

            /* 𝓐𝓬𝓽 */
            var resultModel = testSequenceItemAction.ActionAsync(mockErrorHole.Object, new CancellationToken()).Result;

            /* 𝓐𝓼𝓼𝓮𝓻𝓽 */
            var result = (ISequenceItemResult)testSequenceItemAction;

            result.IsFail.Should().BeFalse();
            result.Exception.Should().BeNull();
            result.ActionResult.Should().Be(testParams.Model);

            result.NewVariables.Should().ContainSingle();
            result.NewVariables.Single().Value.Should().BeAssignableTo<IDictionary<string, object>>();
            var actualData = result.NewVariables.Single().Value  as IDictionary<string, object>;

            actualData.Should().HaveCount(3);
            actualData.Should().ContainKeys(new[] { "prop1", "array1", "complexObj1" });

            var actualDataDict = actualData as IDictionary<string, object>;

            actualDataDict["prop1"].Should().Be("prop1Data");
            actualDataDict["array1"].Should().BeAssignableTo<List<object>>();
            var actualArray = (List<object>)actualDataDict["array1"];
            actualArray.Should().ContainInOrder(new [] { "array1a", "array2a" });

            var actualDyanmic = actualData as dynamic;
            var actualComplexProperty = (string)actualDyanmic.complexObj1.complexObjProp1;
            actualComplexProperty.Should().Be("complexObjProp1Data");

            AssertErrorHoleEmpty();

            /* 𝓢𝓮𝓺𝓾𝓮𝓷𝓬𝓮 𝓓𝓲𝓪𝓰𝓻𝓪𝓶 */
            var sequenceNotation = container.Resolve<ILogSequence>().GetSequenceDiagramNotation(MethodBase.GetCurrentMethod().Name);
            mrOutput.WriteLine(sequenceNotation);
        }

    }
}
